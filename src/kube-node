#!/bin/bash

set -e

USAGE=$(cat <<EOF
Usage: kube-node <Command>

Commands:
    master init <Node IP> <API IP> [API Interface]
    master join <Node IP> <API IP>
    master join-info
    master delete [Node Name]
    master pki make <PKI Archive>
    master pki install <PKI Archive>

    worker join <Node IP> <API IP> <Join Info>
    worker delete <Node Name>

    reset

    role set <Role> [Node Name]
    role unset <Role> [Node Name]
EOF
)

function main {
    START_TIME="$(start_time)"

    case "$1 $2 $3 $4 $5" in
        "master init $3 $4 $5")
            local NODE_IP="$3"
            local API_IP="$4"
            local API_IFACE="$5"

            if [ -z "${NODE_IP}" ] || [ -z "${API_IP}" ]; then usage; fi

            master_init "${NODE_IP}" "${API_IP}" "${API_IFACE}"
            show_completion_time "${START_TIME}"
        ;;
        "master join $3 $4 $5")
            local NODE_IP="$3"
            local API_IP="$4"

            if [ -z "${NODE_IP}" ] || [ -z "${API_IP}" ]; then usage; fi

            master_join "${NODE_IP}" "${API_IP}"
            show_completion_time "${START_TIME}"
        ;;
        "master join-info   ")
            master_join_info
        ;;
        "master delete $3  ")
            local NODE_NAME="$3"

            master_delete "${NODE_NAME}"
            show_completion_time "${START_TIME}"
        ;;
        "master pki make $4 "|\
        "master pki install $4 ")
            local PKI_ACTION="$3"
            local PKI_ARCHIVE="$4"

            if [ -z "${PKI_ARCHIVE}" ]; then usage; fi

            "master_pki_${PKI_ACTION}" "${PKI_ARCHIVE}"
            show_completion_time "${START_TIME}"
        ;;
        "worker join $3 $4 $5")
            local NODE_IP="$3"
            local API_IP="$4"
            shift 4
            local JOIN_INFO=$*

            if [ -z "${NODE_IP}" ] || [ -z "${API_IP}" ] || \
               [ -z "${JOIN_INFO}" ]; then usage; fi

            worker_join "${NODE_IP}" "${API_IP}" "${JOIN_INFO}"
            show_completion_time "${START_TIME}"
        ;;
        "worker delete $3  ")
            local NODE_NAME="$3"

            if [ -z "${NODE_NAME}" ]; then usage; fi

            worker_delete "${NODE_NAME}"
            show_completion_time "${START_TIME}"
        ;;
        "reset    ")
            node_reset
            show_completion_time "${START_TIME}"
        ;;
        "role set $3 $4 ")
            local ROLE="$3"
            local NODE_NAME="$4"

            if [ -z "${ROLE}" ]; then usage; fi

            node_role set "${ROLE}" "${NODE_NAME}"
        ;;
        "role unset $3 $4 ")
            local ROLE="$3"
            local NODE_NAME="$4"

            if [ -z "${ROLE}" ]; then usage; fi

            node_role unset "${ROLE}" "${NODE_NAME}"
        ;;
        *) usage ;;
    esac
}

function k8s_version {
    /opt/bin/kubelet --version | sed "s/.* //"
}
function kubeadm {
    sudo /opt/bin/kubeadm --config "$(kubeadm_config)" "$@"
}
function kubeadm_alpha {
    kubeadm alpha phase "$@"
}
function kubeadm_config {
    echo "/etc/kubernetes/kubeadm.conf"
}
function kubectl {
    sudo /opt/bin/kubectl --kubeconfig "$(kubeconfig)" $*
}
function kubeconfig {
    echo "/etc/kubernetes/kubeconfig"
}
function kubeconfig_master {
    echo "/etc/kubernetes/admin.conf"
}
function kubeconfig_worker {
    echo "/etc/kubernetes/kubelet.conf"
}

function templates {
    echo "/etc/kubernetes/templates"
}

function node_name {
    hostname -s
}
function cluster_name {
    hostname -d
}
function node_hostname {
    hostname -f
}
function api_hostname {
    echo "k8s.$(cluster_name)"
}

function master_prepare {
    local CLUSTER_STATE="$1"
    local NODE_IP="$2"

    log "Preparing master for the ${CLUSTER_STATE} $(cluster_name)..."

    local ETCD_STATE="${CLUSTER_STATE}"
    [ "${CLUSTER_STATE}" = "existing" ] && ETCD_CLUSTER="$(etcd_cluster)"

    sudo sed -e "s/_K8S_VERSION_/$(k8s_version)/g" \
             -e "s/_API_HOSTNAME_/$(api_hostname)/g" \
             -e "s/_NODE_HOSTNAME_/$(node_hostname)/g" \
             -e "s/_NODE_IP_/${NODE_IP}/g" \
             -e "s\\_ETCD_CLUSTER_\\${ETCD_CLUSTER}\\g" \
             -e "s/_ETCD_STATE_/${ETCD_STATE}/g" \
             "$(templates)/kubeadm.yaml" | \
         sudo tee "$(kubeadm_config)" > /dev/null
    sudo chmod 600 "$(kubeadm_config)"
}
function master_init {
    local NODE_IP="$1"
    local API_IP="$2"
    local API_IFACE="$3"

    resolve_node_hostname_to "${NODE_IP}"
    resolve_api_hostname_to "${NODE_IP}"
    master_prepare new "${NODE_IP}"

    log "Initialising first master of $(cluster_name)..."
    kubeadm init

    sudo ln -s "$(kubeconfig_master)" "$(kubeconfig)"
    node_role set master

    log "Installing Calico..."
    kubectl create --filename "$(templates)/calico-rbac-kdd.yaml"
    kubectl create --filename "$(templates)/calico.yaml"

    if [ -n "${API_IFACE}" ]; then
        install_kubealived "${API_IP}" "${API_IFACE}"
    fi
    if [ "${NODE_IP}" != "${API_IP}" ]; then
        resolve_api_hostname_to "${API_IP}"
    fi

    log "Waiting for Etcd..."
    wait_for etcd_ready

    log "Installing Multus CNI..."
    kubectl create --filename "$(templates)/multus-cni-rbac.yaml"
    kubectl create --filename "$(templates)/multus-cni.yaml"
}
function master_join {
    local NODE_IP="$1"
    local API_IP="$2"

    sudo ln -s "$(kubeconfig_master)" "$(kubeconfig)"

    resolve_node_hostname_to "${NODE_IP}"
    resolve_api_hostname_to "${API_IP}"
    master_prepare existing "${NODE_IP}"

    log "Joining master to $(cluster_name)..."
    kubeadm_alpha certs all
    kubeadm_alpha kubelet config write-to-disk
    kubeadm_alpha kubelet write-env-file
    kubeadm_alpha kubeconfig kubelet
    sudo systemctl start kubelet

    local ETCD_HOSTNAME; ETCD_HOSTNAME="$(etcd_hostname)"
    local ETCD_IP; ETCD_IP="$(etcd_ip)"

    log "Joining Etcd ${ETCD_HOSTNAME} (${ETCD_IP})..."
    kubectl --namespace kube-system \
            exec "etcd-${ETCD_HOSTNAME}" -- \
       etcdctl --ca-file /etc/kubernetes/pki/etcd/ca.crt \
               --key-file /etc/kubernetes/pki/etcd/peer.key \
               --cert-file /etc/kubernetes/pki/etcd/peer.crt \
               --endpoints="https://${ETCD_IP}:2379" \
           member add "$(node_hostname)" "https://${NODE_IP}:2380"

    kubeadm_alpha etcd local
    kubeadm_alpha kubeconfig all
    kubeadm_alpha controlplane all
    kubeadm_alpha kubelet config annotate-cri
    kubeadm_alpha mark-master

    node_role set master

    log "Waiting for Etcd..."
    wait_for etcd_ready
}
function master_join_info {
    local TOKEN; TOKEN="$(join_token)"
    TOKEN="${TOKEN:-$(join_token_create)}"

    printf %b "--token ${TOKEN} " \
              "$(api_server_ip):$(api_server_port) " \
              "--discovery-token-ca-cert-hash " \
                  "sha256:$(discovery_token_ca_cert_hash)"
}
function master_delete {
    local NODE_NAME; NODE_NAME="${1:-$(node_name)}"
    local NODE; NODE="${NODE_NAME}.$(cluster_name)"

    log "Deleting ${NODE_NAME} from $(cluster_name)..."

    node_role unset master "${NODE_NAME}"

    log "Waiting for Kubealived is terminated on ${NODE_NAME}..."
    wait_for kubealived_terminated "${NODE_NAME}"

    local ETCD_HOSTNAME; ETCD_HOSTNAME="$(etcd_hostname_this)"
    local ETCD_IP; ETCD_IP="$(etcd_ip_this)"

    log "Retrieving ${NODE_NAME} Etcd ID..."
    local ETCD_ID; ETCD_ID=$(kubectl --namespace kube-system \
            exec "etcd-${ETCD_HOSTNAME}" -- \
        etcdctl --ca-file /etc/kubernetes/pki/etcd/ca.crt \
                --key-file /etc/kubernetes/pki/etcd/peer.key \
                --cert-file /etc/kubernetes/pki/etcd/peer.crt \
                --endpoints="https://${ETCD_IP}:2379" \
            member list | grep "${NODE}" | sed s/:.*//)

    log "Removing Etcd member ${NODE_NAME} (id: ${ETCD_ID})..."
    kubectl --namespace kube-system \
            exec "etcd-${ETCD_HOSTNAME}" -- \
        etcdctl --ca-file /etc/kubernetes/pki/etcd/ca.crt \
                --key-file /etc/kubernetes/pki/etcd/peer.key \
                --cert-file /etc/kubernetes/pki/etcd/peer.crt \
                --endpoints="https://${ETCD_IP}:2379" \
            member remove "${ETCD_ID}"

    kubectl delete node "${NODE}"
}
function master_pki_make {
    local ARCHIVE="$1"

    log "Making PKI archive ${ARCHIVE}..."

    mkdir -p kubernetes/pki/etcd
    sudo cp /etc/kubernetes/pki/{ca.{crt,key},sa.{key,pub}} kubernetes/pki
    sudo cp /etc/kubernetes/pki/front-proxy-ca.{crt,key} kubernetes/pki
    sudo cp /etc/kubernetes/pki/etcd/ca.{crt,key} kubernetes/pki/etcd
    sudo cp /etc/kubernetes/admin.conf kubernetes

    sudo chown -R "${USER}:${USER}" kubernetes
    tar zcf "${ARCHIVE}" kubernetes
    rm -rf kubernetes
}
function master_pki_install {
    local ARCHIVE="$1"

    log "Installing existing PKI from ${ARCHIVE}..."
    sudo tar xf "${ARCHIVE}" -C /etc
    sudo chown -R root:root /etc/kubernetes
    rm "${ARCHIVE}"
}

function worker_join {
    local NODE_IP="$1"
    local API_IP="$2"
    shift 2
    local JOIN_INFO=$*

    log "Joining worker to $(cluster_name)..."

    resolve_node_hostname_to "${NODE_IP}"
    resolve_api_hostname_to "${API_IP}"

    kubelet_extra_set

    sudo mkdir -m 700 -p /etc/kubernetes/manifests
    sudo /opt/bin/kubeadm join ${JOIN_INFO}

    sudo ln -s "$(kubeconfig_worker)" "$(kubeconfig)"
    node_role set worker
}
function worker_delete {
    local NODE_NAME="$1"
    kubectl delete node "${NODE_NAME}.$(cluster_name)"
}

function node_reset {
    log "Resetting node of $(cluster_name)..."

    sudo /opt/bin/kubeadm reset --force
    sudo rm -f "$(kubeadm_config)"
    sudo rm -f "$(kubeconfig)"

    cni_reset
    resolve_reset
    kubelet_extra_reset
}

function node_role {
    local ACTION="$1"
    local ROLE="$2"
    local NODE_NAME; NODE_NAME="${3:-$(node_name)}"

    case "${ACTION} ${ROLE}" in
        "set worker") node_role_taint unset master "${NODE_NAME}" ;;
        "unset worker") if node_has_role_label master "${NODE_NAME}"; then
                            node_role_taint set master "${NODE_NAME}"
                        fi ;;
        "set master") if ! node_has_role_label worker "${NODE_NAME}"; then
                          node_role_taint set master "${NODE_NAME}"
                      fi ;;
        *) node_role_taint "${ACTION}" "${ROLE}" "${NODE_NAME}" ;;
    esac

    node_role_label "${ACTION}" "${ROLE}" "${NODE_NAME}"
}
function node_role_label {
    local ACTION="$1"
    local ROLE="$2"
    local NODE_NAME="$3"

    local NODE; NODE="${NODE_NAME}.$(cluster_name)"
    local LABEL="node-role.kubernetes.io/${ROLE}"

    case "${ACTION}" in
          set) if ! node_has_role_label "${ROLE}" "${NODE_NAME}"; then
                   kubectl label node "${NODE}" "${LABEL}=true" --overwrite
               fi ;;
        unset) if node_has_role_label "${ROLE}" "${NODE_NAME}"; then
                   kubectl label node "${NODE}" "${LABEL}-"
               fi ;;
    esac
}
function node_role_taint {
    local ACTION="$1"
    local ROLE="$2"
    local NODE_NAME="$3"

    local NODE; NODE="${NODE_NAME}.$(cluster_name)"
    local TAINT="node-role.kubernetes.io/${ROLE}"

    case "${ACTION}" in
          set) if ! node_has_role_taint "${ROLE}" "${NODE_NAME}"; then
                   kubectl taint node "${NODE}" "${TAINT}=:NoSchedule"
               fi ;;
        unset) if node_has_role_taint "${ROLE}" "${NODE_NAME}"; then
                   kubectl taint node "${NODE}" "${TAINT}:NoSchedule-"
               fi ;;
    esac
}
function node_has_role_label {
    local ROLE="$1"
    local NODE_NAME="$2"

    local NODE; NODE="${NODE_NAME}.$(cluster_name)"
    local LABEL="node-role\\.kubernetes\\.io/${ROLE}"

    local JP="jsonpath={.metadata.labels.${LABEL}}"
    [ "$(kubectl get node "${NODE}" -o "${JP}")" = "true" ]
}
function node_has_role_taint {
    local ROLE="$1"
    local NODE_NAME="$2"

    local NODE; NODE="${NODE_NAME}.$(cluster_name)"
    local TAINT="node-role.kubernetes.io/${ROLE}"

    local JP="jsonpath={.spec.taints[?(@.key==\"${TAINT}\")].effect}"
    [ "$(kubectl get node "${NODE}" -o "${JP}")" = "NoSchedule" ]
}

function install_kubealived {
    local API_IP="$1"
    local API_IFACE="$2"

    log "Installing Kubealived..."
    sudo sed -e "s/_IP_/${API_IP}/" \
             -e "s/_IFACE_/${API_IFACE}/" \
             -e "s/_PASSWORD_/$(openssl rand -base64 8)/" \
             "$(templates)/kubealived.yaml" | \
         kubectl create --filename -

    log "Waiting for Kubealived..."
    wait_for kubealived_ready
}
function kubealived_ready {
    [ "$(pods "" kubealived-system app=kubealived \
              "{.items[0].status.containerStatuses[0].ready}" \
              2>/dev/null)" = "true" ]
}
function kubealived_terminated {
    local NODE_NAME="$1"
    local NODE; NODE="${NODE_NAME}.$(cluster_name)"

    local JP="jsonpath={.items[?(@.spec.nodeName==\"${NODE}\")].status.phase}"

    local PHASE
    PHASE="$(kubectl -n kubealived-system get po -o "$JP")" && [ -z "${PHASE}" ]
}

function etcd_cluster {
    JSONPATH=$(printf %b \
        '{range.items[*]}' \
            '{.spec.nodeName}{"=https://"}{.status.podIP}{":2380,"}' \
        '{end}')
    pods "" kube-system component=etcd "${JSONPATH}"
}
function etcd_hostname {
    pods "" kube-system component=etcd "{.items[0].spec.nodeName}"
}
function etcd_hostname_this {
    pods "" kube-system component=etcd \
        "{.items[?(@.spec.nodeName==\"$(node_hostname)\")].spec.nodeName}"
}
function etcd_ip {
    pods "" kube-system component=etcd "{.items[0].status.podIP}"
}
function etcd_ip_this {
    pods "" kube-system component=etcd \
        "{.items[?(@.spec.nodeName==\"$(node_hostname)\")].status.podIP}"
}
function etcd_ready {
    [ "$(pods "etcd-$(node_hostname)" kube-system "" \
              "{.status.containerStatuses[0].ready}" 2>/dev/null)" = "true" ]
}

function api_server_command {
    pods "" kube-system component=kube-apiserver \
         "{.items[0].spec.containers[0].command[*]}"
}
function api_server_ip {
    api_server_command | sed "s/.*--advertise-address=\\([0-9|.]\\+\\).*/\\1/"
}
function api_server_port {
    api_server_command | sed "s/.*--secure-port=\\([0-9]\\+\\).*/\\1/"
}

function pods {
    local POD_NAME="$1"
    local NAMESPACE="${2:+--namespace $2}"
    local SELECTOR="${3:+--selector $3}"
    local JSONPATH="${4:+--output jsonpath=$4}"

    kubectl get pods "${POD_NAME}" "${NAMESPACE}" "${SELECTOR}" "${JSONPATH}"
}

function cni_reset {
    echo "Resetting CNI..."
    sudo find /opt/cni/bin -type f -exec rm -f "{}" 2>/dev/null \; || true
    sudo find /etc/cni/net.d -type f -exec rm -f "{}" 2>/dev/null \; || true
    sudo rmdir -p /opt/cni/bin 2>/dev/null || true
    sudo rmdir -p /etc/cni/net.d 2>/dev/null || true
}

function kubelet_extra_set {
    echo "Setting Kubelet extra flags..."

    printf %b "KUBELET_EXTRA_ARGS=" \
              "--allowed-unsafe-sysctls=net.* " | \
        sudo tee /etc/default/kubelet

    sudo chmod 600 /etc/default/kubelet
}
function kubelet_extra_reset {
    echo "Resetting Kubelet extra flags..."
    sudo rm -f /etc/default/kubelet
}

function resolve_node_hostname_to {
    local IP="$1"
    ensure_in_hosts "${IP}" "$(node_hostname)"
}
function resolve_api_hostname_to {
    local IP="$1"
    ensure_in_hosts "${IP}" "$(api_hostname)"
}
function resolve_reset {
    delete_from_hosts "$(node_hostname)"
    delete_from_hosts "$(api_hostname)"
}
function ensure_in_hosts {
    local IP="$1"
    local HOSTNAME="$2"

    log "Ensuring ${IP} ${HOSTNAME} is in /etc/hosts..."
    if grep -q "${HOSTNAME}" /etc/hosts; then
        sudo sed -i "s/.* \\(${HOSTNAME}\\)/${IP}    \\1/" /etc/hosts
    else
        sudo sed -i "$ a ${IP}    ${HOSTNAME}" /etc/hosts
    fi
}
function delete_from_hosts {
    local HOSTNAME="$1"

    log "Deleting ${HOSTNAME} from /etc/hosts..."
    sudo sed -i "/${HOSTNAME}/d" /etc/hosts
}

function join_token {
    sudo /opt/bin/kubeadm token list | sed -n 2p | sed "s/ .*//"
}
function join_token_create {
    sudo /opt/bin/kubeadm token create
}
function discovery_token_ca_cert_hash {
    openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | \
        openssl rsa -pubin -outform der 2>/dev/null | \
            openssl dgst -sha256 -hex | sed "s/^.* //"
}

function wait_for {
    local CONDITION="$1"
    shift

    while ! "${CONDITION}" "$@"; do
        echo -en "\\b=>"
        sleep 2
    done
    echo -e "\\b."
}

function start_time {
    date +%s
}
function show_completion_time {
    local START_TIME="$1"
    local END_TIME; END_TIME="$(date +%s)"
    log "Complete in $(date -d@$((END_TIME - START_TIME)) -u +%Mm%Ss)."
}
function log {
    echo "$(date -uIseconds | sed s/\+.*//) [$(node_name)]" "$@"
}
function usage {
    >&2 echo "${USAGE}"
    exit 2
}

main "$@"
