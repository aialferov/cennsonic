#!/bin/bash

set -e

USAGE=`cat <<EOF
Usage: kube-node <Command>

Commands:
    master init <Node IP> <API IP> [API Interface]
    master join <Node IP> <API IP> <PKI Archive>
    master pki make <PKI Archive>
    master info join
    worker join <Node IP> <API IP> <Join Info>
    reset
EOF`

function usage {
    >&2 echo "${USAGE}"
    exit 2
}

function k8s_version {
    /opt/bin/kubelet --version | sed 's/.* //'
}

function prefix {
    echo "[$(date -uIseconds | sed s/\+.*//)][$(hostname -s)]"
}
function node_hostname {
    hostname -f
}
function cluster_name {
    hostname -d
}
function api_hostname {
    echo "k8s.$(cluster_name)"
}

function ensure_in_hosts {
    local IP="$1"
    local HOSTNAME="$2"

    echo "$(prefix) Ensuring ${IP} ${HOSTNAME} is in /etc/hosts..."
    grep -q "${HOSTNAME}" /etc/hosts && \
        sudo sed -i "s/.* \(${HOSTNAME}\)/${IP}    \1/" /etc/hosts || \
        sudo sed -i "$ a ${IP}    ${HOSTNAME}" /etc/hosts
}
function delete_from_hosts {
    local HOSTNAME="$1"

    echo "$(prefix) Deleting ${HOSTNAME} from /etc/hosts..."
    sudo sed -i "/${HOSTNAME}/d" /etc/hosts
}
function resolve_node_to {
    local IP="$1"
    ensure_in_hosts "${IP}" "$(node_hostname)"
}
function resolve_api_to {
    local IP="$1"
    ensure_in_hosts "${IP}" "$(api_hostname)"
}
function reset_resolving {
    delete_from_hosts "$(node_hostname)"
    delete_from_hosts "$(api_hostname)"
}

function pki_make {
    local ARCHIVE="$1"

    echo "$(prefix) Making PKI archive ${ARCHIVE}..."

    mkdir -p kubernetes/pki/etcd
    sudo cp /etc/kubernetes/pki/{ca.{crt,key},sa.{key,pub}} kubernetes/pki
    sudo cp /etc/kubernetes/pki/front-proxy-ca.{crt,key} kubernetes/pki
    sudo cp /etc/kubernetes/pki/etcd/ca.{crt,key} kubernetes/pki/etcd
    sudo cp /etc/kubernetes/admin.conf kubernetes

    sudo chown -R "${USER}:${USER}" kubernetes
    tar zcf "${ARCHIVE}" kubernetes
    rm -rf kubernetes
}
function pki_install {
    local ARCHIVE="$1"

    echo "$(prefix) Installing existing PKI from ${ARCHIVE}..."
    sudo tar xf "${ARCHIVE}" -C /etc
    sudo chown -R root:root /etc/kubernetes
    rm "${ARCHIVE}"
}

function manifests {
    echo "/etc/kubernetes/manifests"
}
function templates {
    echo "/etc/kubernetes/templates"
}
function template_to_manifest {
    local FILE="$1"
    local TEMPLATE="$(templates)/${FILE}"
    local MANIFEST="$(manifests)/${FILE}"
    shift

    sudo mkdir -m 700 -p "$(manifests)"

    if [ -n "$*" ]; then
        sed $* "${TEMPLATE}" | sudo tee "${MANIFEST}" > /dev/null
    else
        sudo cp "${TEMPLATE}" "${MANIFEST}"
    fi
    sudo chmod 600 "${MANIFEST}"
}

function kubeadm {
    sudo /opt/bin/kubeadm --config "$(manifests)/kubeadm.yaml" $*
}
function kubeadm_alpha {
    kubeadm alpha phase $*
}

function kubectl {
    sudo kubectl --kubeconfig /etc/kubernetes/admin.conf $*
}

function pods {
    local POD_NAME="$1"
    local NAMESPACE="${2:+--namespace $2}"
    local SELECTOR="${3:+--selector $3}"
    local JSONPATH="${4:+--output jsonpath=$4}"

    kubectl get pods "${POD_NAME}" "${NAMESPACE}" "${SELECTOR}" "${JSONPATH}"
}

function etcd_cluster {
    JSONPATH=`printf %b \
        '{range.items[*]}' \
            '{.spec.nodeName}{"=https://"}{.status.podIP}{":2380,"}' \
        '{end}'`
    pods "" kube-system component=etcd "${JSONPATH}"
}
function etcd_hostname {
    pods "" kube-system component=etcd "{.items[0].spec.nodeName}"
}
function etcd_ip {
    pods "" kube-system component=etcd "{.items[0].status.podIP}"
}

function token {
    sudo /opt/bin/kubeadm token list | tail -n-1 | sed 's/ .*//'
}
function discovery_token_ca_cert_hash {
    openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | \
        openssl rsa -pubin -outform der 2>/dev/null | \
            openssl dgst -sha256 -hex | sed 's/^.* //'
}

function api_server_command {
    pods "" kube-system component=kube-apiserver \
         "{.items[0].spec.containers[0].command[*]}"
}
function api_server_ip {
    api_server_command | sed 's/.*\--advertise-address=\([0-9|.]\+\).*/\1/'
}
function api_server_port {
    api_server_command | sed 's/.*\--secure-port=\([0-9]\+\).*/\1/'
}

function etcd_ready {
    [ "$(pods etcd-$(node_hostname) kube-system '' \
              {.status.containerStatuses[0].ready} 2>/dev/null)" != "true" ]
}
function keepalived_ready {
    [ "$(pods '' keepalived-system app=keepalived \
              {.items[0].status.containerStatuses[0].ready} \
              2>/dev/null)" != "true" ]
}

function wait_for {
    local CONDITION="$1"

    while "${CONDITION}"; do
        echo -en "\b=>"
        sleep 2
    done
    echo -e "\b."
}

function install_keepalived {
    local API_IP="$1"
    local API_IFACE="$2"

    echo "$(prefix) Installing Keepalived..."
    template_to_manifest keepalived.yaml \
        -e "s/_IP_/${API_IP}/" \
        -e "s/_IFACE_/${API_IFACE}/" \
        -e "s/_PASSWORD_/$(openssl rand -base64 8)/"
    kubectl apply --filename "$(manifests)/keepalived.yaml"

    echo "$(prefix) Waiting for Keepalived..."
    wait_for keepalived_ready
}

function master_prepare {
    local CLUSTER_STATE="$1"
    local NODE_IP="$2"

    echo "$(prefix) Preparing master for the ${CLUSTER_STATE} $(cluster_name)..."

    local ETCD_STATE="${CLUSTER_STATE}"
    [ "${CLUSTER_STATE}" = "existing" ] && ETCD_CLUSTER="$(etcd_cluster)"

    template_to_manifest kubeadm.yaml \
        -e "s/_K8S_VERSION_/$(k8s_version)/g" \
        -e "s/_API_HOSTNAME_/$(api_hostname)/g" \
        -e "s/_NODE_HOSTNAME_/$(node_hostname)/g" \
        -e "s/_NODE_IP_/${NODE_IP}/g" \
        -e "s\\_ETCD_CLUSTER_\\${ETCD_CLUSTER}\\g" \
        -e "s/_ETCD_STATE_/${ETCD_STATE}/g"
}

function master_init {
    local NODE_IP="$1"
    local API_IP="$2"
    local API_IFACE="$3"

    resolve_node_to "${NODE_IP}"
    resolve_api_to "${NODE_IP}"
    master_prepare new "${NODE_IP}"

    echo "$(prefix) Initialising first master of $(cluster_name)..."
    kubeadm init

    echo "$(prefix) Installing Calico..."
    template_to_manifest calico-rbac-kdd.yaml
    template_to_manifest calico.yaml
    kubectl apply --filename "$(manifests)/calico-rbac-kdd.yaml"
    kubectl apply --filename "$(manifests)/calico.yaml"

    if [ "${NODE_IP}" != "${API_IP}" ]; then
        install_keepalived "${API_IP}" "${API_IFACE}"
        resolve_api_to "${API_IP}"
    fi

    echo "$(prefix) Waiting for Etcd..."
    wait_for etcd_ready
}

function master_join {
    local NODE_IP="$1"
    local API_IP="$2"
    local PKI_ARCHIVE="$3"

    pki_install "${PKI_ARCHIVE}"

    resolve_node_to "${NODE_IP}"
    resolve_api_to "${API_IP}"
    master_prepare existing "${NODE_IP}"

    echo "$(prefix) Joining master to $(cluster_name)..."
    kubeadm_alpha certs all
    kubeadm_alpha kubelet config write-to-disk
    kubeadm_alpha kubelet write-env-file
    kubeadm_alpha kubeconfig kubelet
    sudo systemctl start kubelet

    local ETCD_HOSTNAME="$(etcd_hostname)"
    local ETCD_IP="$(etcd_ip)"

    echo "$(prefix) Joining etcd ${ETCD_HOSTNAME} (${ETCD_IP})..."
    kubectl --namespace kube-system \
            exec "etcd-${ETCD_HOSTNAME}" -- \
       etcdctl --ca-file /etc/kubernetes/pki/etcd/ca.crt \
               --key-file /etc/kubernetes/pki/etcd/peer.key \
               --cert-file /etc/kubernetes/pki/etcd/peer.crt \
               --endpoints="https://${ETCD_IP}:2379" \
           member add $(node_hostname) "https://${NODE_IP}:2380"

    kubeadm_alpha etcd local
    kubeadm_alpha kubeconfig all
    kubeadm_alpha controlplane all
    kubeadm_alpha kubelet config annotate-cri
    kubeadm_alpha mark-master

    echo "$(prefix) Waiting for etcd..."
    wait_for etcd_ready
}

function master_info_join {
    local HASH="$(discovery_token_ca_cert_hash)"

    echo -n "--token $(token) "
    echo -n "$(api_server_ip):$(api_server_port) "
    echo -n "--discovery-token-ca-cert-hash sha256:${HASH}"
}

function worker_join {
    local NODE_IP="$1"
    local API_IP="$2"
    local JOIN_INFO="$3"

    echo "$(prefix) Joining worker to $(cluster_name)..."
    resolve_node_to "${NODE_IP}"
    resolve_api_to "${API_IP}"
    sudo /opt/bin/kubeadm join ${JOIN_INFO}
}
function reset {
    echo "$(prefix) Resetting node of $(cluster_name)..."
    sudo /opt/bin/kubeadm reset -f
    reset_resolving
}

case "$1 $2 $3 $4 $5" in
    "master init $3 $4 $5")
        NODE_IP="$3" API_IP="$4" API_IFACE="$5"
        [ -n "${NODE_IP}" ] && [ -n "${API_IP}" ] || usage
        master_init "${NODE_IP}" "${API_IP}" "${API_IFACE}"
    ;;
    "master join $3 $4 $5")
        NODE_IP="$3" API_IP="$4" PKI_ARCHIVE="$5"
        [ -n "${NODE_IP}" ] && [ -n "${API_IP}" ] && \
        [ -n "${PKI_ARCHIVE}" ] || usage
        master_join "${NODE_IP}" "${API_IP}" "${PKI_ARCHIVE}"
    ;;
    "master pki make $4 ")
        PKI_ARCHIVE="$4"
        [ -n "${PKI_ARCHIVE}" ] || usage
        pki_make "${PKI_ARCHIVE}"
    ;;
    "master info join  ")
        master_info_join
    ;;
    "worker join $3 $4 $5")
        NODE_IP="$3" API_IP="$4" JOIN_INFO="$5"
        [ -n "${NODE_IP}" ] && [ -n "${API_IP}" ] && \
        [ -n "${JOIN_INFO}" ] || usage
        worker_join "${NODE_IP}" "${API_IP}" "${JOIN_INFO}"
    ;;
    "reset    ") reset ;;
    *) usage ;;
esac
